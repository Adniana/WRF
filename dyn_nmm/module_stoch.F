module module_stoch
!***********************************************************************
!
! Purpose: Stochastic Perturbation Schemes
! Author : Judith Berner, NCAR  (berner@ucar.edu)
! Date   : Apr 2014
!
!***********************************************************************
!
! The scheme introduces stochastic perturbations to the rotational wind 
! components and to the potential temperature field. The stochastic 
! perturbations are generated by independent autoregressive processes for 
! each wavenumber and results in smooth spatially and temporally correlated patterns.
! Details of the scheme and its performance in a meso-scale WRF-ensemble 
! system are available in:
!
! Berner, J.,  S.-Y. Ha, J. P. Hacker, A. Fournier and C. Snyder 2011:
! "Model uncertainty in a mesoscale ensemble prediction system: Stochastic 
! versus multi-physics representations",  2011, Mon. Wea. Rev., 139, 1972-1995
! http://journals.ametsoc.org/doi/abs/10.1175/2010MWR3595.1
!
! Features: 
!     Dissipation: Dissipation rates are assumed constant in space and time
!     Vertical structure: Supports two options for vertical structure: 
!                         0) constant
!                         1) random phase
!
! Optional namelist parameters:
!   stoch_force_opt	=	0, 0, 0: No stochastic parameterization
!   			=	1, 1, 1: Use SKEB scheme
!   skebs_vertstruc	=	0, 0, 0: Constant vertical structure of random pattern generator
!   			= 	1, 1, 1: Random phase vertical structure random pattern generator
!   tot_backscat_psi	:	Total backscattered dissipation rate for streamfunction; Controls 
!                               amplitude of rotational wind perturbations Default value is 1.0E-5 m2/s3.
!   tot_backscat_t	:	Total backscattered dissipation rate for potential temperature; 
!   				Controls amplitude of potential temperature perturbations. Default value is 1.0E-6 m2/s3.
!   nens		:	Random seed for random number stream. This parameter needs to be different 
!                               for each member in ensemble forecasts. Is a function of initial start time 
!   				to ensure different random number streams for different forecasts.
!   ztau_psi		:	Decorrelation time (in s) for streamfunction perturbations.
!   				Default is 10800s.  Recommended value is 216000s.
!   ztau_t		:	Decorrelation time (in s) for potential temperature perturbations. 
!   				Default 10800s. Recommended value is 216000s.
!   rexponent_psi	:	Spectral slope for streamfunction perturbations. Default is -1.83 
!                               for a kinetic-energy forcing spectrum with slope -5/3.
!   rexponent_t 	:	Spectral slope of potential temperature perturbations. Default is -1.83 
!   				for a potential energy forcing spectrum with slope -1.832.
!   kminforc		:	Minimal forcing wavenumber in longitude for streamfunction perturbations. Default is 1.
!   lminforc		:	Minimal forcing wavenumber in latitude for streamfunction perturbations. Default is 1.
!   kminforc		: 	Minimal forcing wavenumber in longitude for potential temperature perturbations. Default is 1.
!   lminforct		:	Minimal forcing wavenumber in latitude for potential temperature perturbations. Default is 1.
!   kmaxforc		:	Maximal forcing wavenumber in longitude for streamfunction perturbations. 
!   				Default is maximal possible wavenumbers determined by number of gridpoints.
!   lmaxforc		:	Maximal forcing wavenumber in latitude for streamfunction perturbations. 
!   				Default is maximal possible wavenumbers determined by number of gridpoints.
!   kmaxforct		:	Maximal forcing wavenumber in longitude for potential temperature perturbations. 
!   				Default is maximal possible wavenumbers determined by number of gridpoints.
!   lmaxforct		:	Maximal forcing wavenumber in latitude for potential temperature perturbations. 
!   				Default is maximal possible wavenumbers determined by number of gridpoints.
!   zsigma2_eps		:	Noise variance in autoregressive process defining streamfunction perturbations.
!   zsigma2_eta		:	Noise variance in autoregressive process defining in potential temperature perturbations.

!***********************************************************************
!     ------------------------------------------------------------------
!************** DECLARE FIELDS AND VARIABLES FOR STOCHASTIC BACKSCATTER
!     ------------------------------------------------------------------
      implicit none
      public ::  SETUP_RAND_PERTURB, UPDATE_STOCH,& 
                         do_fftback_along_x,do_fftback_along_y,& 
                         rand_pert_update,perturb_mp_tend

      INTEGER :: LMINFORC, LMAXFORC, KMINFORC, KMAXFORC, & 
      &          LMINFORCT, LMAXFORCT, KMINFORCT, KMAXFORCT
      REAL    :: ALPH, ALPH_PSI, ALPH_T, TOT_BACKSCAT_PSI, TOT_BACKSCAT_T,  REXPONENT_PSI,REXPONENT_T

!     ----------Fields for spectral transform -----------

      INTEGER :: LENSAV
      INTEGER,ALLOCATABLE:: wavenumber_k(:), wavenumber_l(:)
      REAL, ALLOCATABLE :: WSAVE1(:),WSAVE2(:)

!     --------- Others -------------------------------------------------
      REAL, PARAMETER:: RPI= 3.141592653589793 !4.0*atan(1.0) 
      REAL, PARAMETER:: CP= 1006.0 ! specific heat of dry air in J/(Kg*K)= m^2/(K* s^2)
      REAL, PARAMETER:: T0= 300.0 ! Reference temperature in K 

      save


!=======================================================================
contains
!=======================================================================
!     ------------------------------------------------------------------
! This subroutine drives the initialization of the stochastic schemes  

    SUBROUTINE INITIALIZE_STOCH  (grid, config_flags,          &
                          first_trip_for_this_domain,          & 
                          ips, ipe, jps, jpe, kps, kpe,        &
                          ids, ide, jds, jde, kds, kde,        &
                          ims, ime, jms, jme, kms, kme,        &
                          its, ite, jts, jte, kts, kte,        & 
                          imsx, imex, jmsx, jmex, kmsx, kmex,  &
                          ipsx, ipex, jpsx, jpex, kpsx, kpex,  &
                          imsy, imey, jmsy, jmey, kmsy, kmey,  &
                          ipsy, ipey, jpsy, jpey, kpsy, kpey   )


    USE module_configure
    USE module_domain, ONLY : domain
#ifdef DM_PARALLEL
    USE module_dm, ONLY : local_communicator, mytask, ntasks, ntasks_x, ntasks_y, local_communicator_periodic, &
                          wrf_dm_maxval, wrf_err_message, local_communicator_x, local_communicator_y, data_order_xyz
#endif

      IMPLICIT NONE

      TYPE (grid_config_rec_type)            :: config_flags
      TYPE ( domain ), INTENT(INOUT)         :: grid

      INTEGER , INTENT(IN)     ::               ids, ide, jds, jde, kds, kde, &
                                                ims, ime, jms, jme, kms, kme, &
                                                ips, ipe, jps, jpe, kps, kpe, & 
                                                its, ite, jts, jte, kts, kte
      INTEGER , INTENT(IN)     ::               imsx,imex,jmsx,jmex,kmsx,kmex, &
                                                ipsx,ipex,jpsx,jpex,kpsx,kpex, &
                                                imsy,imey,jmsy,jmey,kmsy,kmey, &
                                                ipsy,ipey,jpsy,jpey,kpsy,kpey

      LOGICAL                  ::               first_trip_for_this_domain
      INTEGER                  ::               K 


   IF ( first_trip_for_this_domain ) THEN
     grid%did_stoch = .FALSE.
   END IF

   IF ((( grid%id == 1) .AND. (.NOT. grid%did_stoch)) .AND. &
       (( grid%skebs_on== 1) .OR.( grid%sppt_on== 1) .OR. ( grid%rand_perturb_on== 1))) THEN 

     grid%did_stoch = .TRUE.

     IF (grid%skebs_on==1) then

! Initialize SKEBS
!    Initialize streamfunction (1)
     if (.not.config_flags%restart) then 
         call rand_seed (config_flags, grid%ISEED_SKEBS, grid%iseedarr_skebs , kms, kme)
     endif
     call SETUP_RAND_PERTURB('W',                                         &
                       grid%skebs_vertstruc,config_flags%restart,         &
                       grid%SPSTREAM_AMP,                                 &
                       grid%SPSTREAMFORCS,grid%SPSTREAMFORCC,grid%ALPH_PSI,&
                       grid%VERTSTRUCC,grid%VERTSTRUCS,grid%VERTAMPUV,     &
                       grid%KMINFORCT,grid%KMAXFORCT,                     &
                       grid%LMINFORCT,grid%LMAXFORCT,                     &
                       grid%KMAXFORCTH,grid%LMAXFORCTH,                   &
                       grid%time_step,grid%DX,grid%DY,                    &
                       grid%gridpt_stddev_sppt,                           &
                       grid%lengthscale_sppt,                             &
                       grid%timescale_sppt,                               &
                       grid%TOT_BACKSCAT_PSI,grid%ZTAU_PSI,               &
                       grid%REXPONENT_PSI,                                &
                       ids, ide, jds, jde, kds, kde,                      &
                       ims, ime, jms, jme, kms, kme,                      &
                       its, ite, jts, jte, kts, kte                       )
!    Initialize potential temperature (2)
     call SETUP_RAND_PERTURB('T',                                         &
                       grid%skebs_vertstruc,config_flags%restart,     &
                       grid%SPT_AMP,                                      &
                       grid%SPTFORCS,grid%SPTFORCC,grid%ALPH_T,           &
                       grid%VERTSTRUCC,grid%VERTSTRUCS,grid%VERTAMPT,     &
                       grid%KMINFORCT,grid%KMAXFORCT,                     &
                       grid%LMINFORCT,grid%LMAXFORCT,                     &
                       grid%KMAXFORCTH,grid%LMAXFORCTH,                   &
                       grid%time_step,grid%DX,grid%DY,                    &
                       grid%gridpt_stddev_sppt,                           &
                       grid%lengthscale_sppt,                             &
                       grid%timescale_sppt,                               &
                       grid%TOT_BACKSCAT_T,grid%ZTAU_T,                   &
                       grid%REXPONENT_T,                                  &
                       ids, ide, jds, jde, kds, kde,                      &
                       ims, ime, jms, jme, kms, kme,                      &
                       its, ite, jts, jte, kts, kte                       )
     ENDIF

IF (grid%sppt_on==1) then
! Initialize SPPT (3)
     if (.not.config_flags%restart) then ! set random number seed (else iseedarray is read in from restart files)
         call rand_seed (config_flags, grid%ISEED_SPPT, grid%iseedarr_sppt  , kms, kme)
     endif
     call SETUP_RAND_PERTURB('P',                                         &
                       grid%sppt_vertstruc,config_flags%restart,          &
                       grid%SPPT_AMP,                                     &
                       grid%SPPTFORCC,grid%SPPTFORCS,grid%ALPH_SPPT,      &
                       grid%VERTSTRUCC,grid%VERTSTRUCS,grid%VERTAMPT,     &
                       grid%KMINFORCT,grid%KMAXFORCT,                     &
                       grid%LMINFORCT,grid%LMAXFORCT,                     &
                       grid%KMAXFORCTH,grid%LMAXFORCTH,                   &
                       grid%time_step,grid%DX,grid%DY,                    &
                       grid%gridpt_stddev_sppt,                           &
                       grid%lengthscale_sppt,                             &
                       grid%timescale_sppt,                               &
                       grid%TOT_BACKSCAT_PSI,grid%ZTAU_PSI,               &
                       grid%REXPONENT_PSI,                                &
                       ids, ide, jds, jde, kds, kde,                      &
                       ims, ime, jms, jme, kms, kme,                      &
                       its, ite, jts, jte, kts, kte                       )
     ENDIF

! Initialize RAND_PERTURB (4)
     IF (grid%rand_perturb_on==1) then
     if (.not.config_flags%restart) then ! set random number seed (else iseedarray is read in from restart files)
         call rand_seed (config_flags, grid%ISEED_RAND_PERT, grid%iseedarr_rand_pert  , kms, kme)
     endif
     call SETUP_RAND_PERTURB('R',                                         &
                       grid%rand_pert_vertstruc,config_flags%restart,     &
                       grid%SP_AMP,                                       &
                       grid%SPFORCC,grid%SPFORCS,grid%ALPH_RAND,          &
                       grid%VERTSTRUCC,grid%VERTSTRUCS,grid%VERTAMPT,     &
                       grid%KMINFORCT,grid%KMAXFORCT,                     &
                       grid%LMINFORCT,grid%LMAXFORCT,                     &
                       grid%KMAXFORCTH,grid%LMAXFORCTH,                   &
                       grid%time_step,grid%DX,grid%DY,                    &
                       grid%gridpt_stddev_rand_pert,                      &
                       grid%lengthscale_rand_pert,                        &
                       grid%timescale_rand_pert,                          &
                       grid%TOT_BACKSCAT_PSI,grid%ZTAU_PSI,               &
                       grid%REXPONENT_PSI,                                &
                       ids, ide, jds, jde, kds, kde,                      &
                       ims, ime, jms, jme, kms, kme,                      &
                       its, ite, jts, jte, kts, kte                       )

     if (.not.config_flags%restart) then ! spin up 
        do k = 1,10
           CALL RAND_PERT_UPDATE(grid,'R',                                     &
                           grid%SPFORCS,grid%SPFORCC,                          &
                           grid%SP_AMP,grid%ALPH_RAND,                         &
                           ips, ipe, jps, jpe, kps, kpe,                       &
                           ids, ide, jds, jde, kds, kde,                       &
                           ims, ime, jms, jme, kms, kme,                       &
                           kts, kte,                                           &
                           imsx,imex,jmsx,jmex,kmsx,kmex,                      &
                           ipsx,ipex,jpsx,jpex,kpsx,kpex,                      &
                           imsy,imey,jmsy,jmey,kmsy,kmey,                      &
                           ipsy,ipey,jpsy,jpey,kpsy,kpey,                      &
                           grid%num_stoch_levels,grid%num_stoch_levels,        &
                           grid%num_stoch_levels,grid%num_stoch_levels,        &
                           config_flags%restart, grid%iseedarr_rand_pert,      &
                           grid%DX,grid%DY,grid%rand_pert_vertstruc,           &
                           grid%RAND_PERT,                                     &
                           grid%VERTSTRUCC,grid%VERTSTRUCS,grid%VERTAMPT       )
         enddo
       ENDIF !rand_perturb_on
     ENDIF

     ENDIF ! skebs or sppt or rand_perturb
 
     END SUBROUTINE INITIALIZE_STOCH       

!     ------------------------------------------------------------------
!!******** INITIALIZE STOCHASTIC SCHEMES   ****************************
!     ------------------------------------------------------------------

      subroutine SETUP_RAND_PERTURB( variable_in,& 
                       skebs_vertstruc,restart,                  & 
                       SP_AMP,SPFORCC,SPFORCS,ALPH,                  & 
                       VERTSTRUCC,VERTSTRUCS,VERTAMP,                &
                       KMINFORCT,KMAXFORCTH,LMINFORCT,LMAXFORCTH,    & 
                       KMAXFORCT,LMAXFORCT,                          &
                       itime_step,DX,DY,                             &
                       gridpt_stddev_rand_perturb, l_rand_perturb,   & 
                       tau_rand_perturb,                             &
                       TOT_BACKSCAT,ZTAU,REXPONENT,                  & 
                       ids, ide, jds, jde, kds, kde,                 &
                       ims, ime, jms, jme, kms, kme,                 &
                       its, ite, jts, jte, kts, kte                  )



      IMPLICIT NONE

! General control 
      LOGICAL                                   :: restart
      REAL, PARAMETER                           :: RPI= 3.141592653589793 !4.0*atan(1.0) 
      CHARACTER, INTENT(IN)                     :: variable_in ! W=SKEBS_PSI, T=SKEBS_T, P=SPPT, R=RAND_PERTURB
      CHARACTER                                 :: variable

! Common to all schemes
      INTEGER , INTENT(IN)                      :: ids, ide, jds, jde, kds, kde,   &
                                                   ims, ime, jms, jme, kms, kme,   &
                                                   its, ite, jts, jte, kts, kte
      INTEGER                                   :: IER,IK,IL,I,J,itime_step,skebs_vertstruc, & 
                                                   KMINFORCT,LMINFORCT,KMAXFORCT,LMAXFORCT,KMAXFORCTH,LMAXFORCTH, & 
                                                   KMAX,LMAX,LENSAV,ILEV
      REAL                                      :: DX,DY,RY,RX,ALPH,RHOKLMAX,ZREF,RHOKL,EPS
      REAL, DIMENSION (ims:ime,jms:jme)         :: SPFORCS,SPFORCC,SP_AMP
      REAL, DIMENSION (ims:ime,jms:jme,kms:kme) :: VERTSTRUCC,VERTSTRUCS !xiaohzhao
      REAL, DIMENSION (kms:kme)                 :: VERTAMP
      REAL, DIMENSION (ids:ide,jds:jde)         :: ZCHI

! SPPT and perturb_rand specific 
      REAL                                      :: gridpt_stddev_rand_perturb,kappat,tau_rand_perturb,l_rand_perturb
      REAL, DIMENSION (ims:ime,jms:jme)         :: var_sigma1


! SKEBS specific
      REAL                                      :: z,phi,ZGAMMAN,ZCONSTF0,TOT_BACKSCAT,ZTAU,REXPONENT,ZSIGMA2
      LOGICAL                                   :: is_print = .true.
      
      variable = variable_in
!     --------- SETUP PARAMETERS ---------------------------------------
      KMAX=(jde-jds)+1 !NLAT
      LMAX=(ide-ids)+1 !NLON
      RY=  KMAX*DY
      RX=  LMAX*DY
      LENSAV= 4*(KMAX+LMAX)+INT(LOG(REAL(KMAX))) + INT(LOG(REAL(LMAX))) + 8
      

!     --------- ALLOCATE FIELDS FOR FFTPACK----------------------------
!     --------- ALLOCATE FIELDS FOR FFTPACK----------------------------
      IF ( ALLOCATED(WSAVE1)      ) DEALLOCATE(WSAVE1)
      IF ( ALLOCATED(WSAVE2)      ) DEALLOCATE(WSAVE2)
      ALLOCATE(WSAVE1(LENSAV),WSAVE2(LENSAV))

      IF ( ALLOCATED(WAVENUMBER_K)) DEALLOCATE(WAVENUMBER_K)
      IF ( ALLOCATED(WAVENUMBER_L)) DEALLOCATE(WAVENUMBER_L)
      ALLOCATE (wavenumber_k(jds:jde),wavenumber_l(ids:ide))

!     -------- INITIALIZE FFTPACK ROUTINES -----------------------------
      call CFFT1I (LMAX, WSAVE1, LENSAV, IER)
      if(ier.ne. 0) write(*,95) ier

      call CFFT1I (KMAX, WSAVE2, LENSAV, IER)
      if(ier.ne. 0) write(*,95) ier

      95 format('error in cFFT2I=  ',i5)

      call findindex( wavenumber_k, wavenumber_l,             &
                      ids, ide, jds, jde, kds, kde,                &
                      ims, ime, jms, jme, kms, kme,                &
                      its, ite, jts, jte, kts, kte                 )

!    set maximal perturbed wavenumber based on gridpoints in domain
     KMAXFORCT=min0(((ide-ids)+1)/2,((jde-jds)+1 )/2)-5
     LMAXFORCT=KMAXFORCT
     if (KMAXFORCT > KMAXFORCTH) then
        KMAXFORCT=KMAXFORCTH
     endif
     if (LMAXFORCT > LMAXFORCTH) then
        LMAXFORCT=LMAXFORCTH
     endif


!     --------------------------------------------------------------------------------------
!     ---------- INITIALIZE STOCHASTIC KINETIC-ENERGY BACKSCATTER SCHEME  (SKEBS) ----------
!     --------------------------------------------------------------------------------------
      ALPH   =  float(itime_step)/ZTAU ! approximation of 1.-exp(-itime_step/ZTAU_PSI)
      ZSIGMA2=1./(12.0*ALPH)

      if (is_print) then
      IF (variable == 'W') then
      WRITE(*,'(''                                               '')')
      WRITE(*,'('' =============================================='')')
      WRITE(*,'('' >> Initializing STREAMFUNCTION forcing pattern of  << '')')
      WRITE(*,'('' >> stochastic kinetic-energy backscatter scheme << '')')
      WRITE(*,'('' Total backscattered energy, TOT_BACKSCAT_PSI '',E12.5)') TOT_BACKSCAT
      WRITE(*,'('' Exponent for energy spectra, REXPONENT_PSI ='',E12.5)') REXPONENT
      WRITE(*,'('' Minimal wavenumber of streamfunction forcing, LMINFORC ='',I10)') LMINFORCT
      WRITE(*,'('' Maximal wavenumber of streamfunction forcing, LMAXFORC ='',I10)') LMAXFORCT
      WRITE(*,'('' Minimal wavenumber of streamfunction forcing, KMINFORC ='',I10)') KMINFORCT
      WRITE(*,'('' Maximal wavenumber of streamfunction forcing, KMAXFORC ='',I10)') KMAXFORCT
      WRITE(*,'('' skebs_vertstruc                             '',I10)') skebs_vertstruc
      WRITE(*,'('' Time step: itime_step='',I10)') itime_step
      WRITE(*,'('' Decorrelation time of noise, ZTAU_PSI ='',E12.5)') ZTAU
      WRITE(*,'('' Variance of noise, ZSIGMA2_EPS  ='',E12.5)') ZSIGMA2
      WRITE(*,'('' Autoregressive parameter 1-ALPH_PSI ='',E12.5)') 1.-ALPH
      WRITE(*,'('' =============================================='')')

!     Unit of SPSTREAM_AMP: sqrt(m^2/s^3 1/s m**2(p+1)) m**-2(p/2) = m^/s^2 * m**[(p+1)-p] = m^2/s^2 m
      ELSEIF (variable == 'T') then
      WRITE(*,'(''                                               '')')
      WRITE(*,'('' =============================================='')')
      WRITE(*,'('' >> Initializing TEMPERATURE forcing pattern of  << '')')
      WRITE(*,'('' >> stochastic kinetic-energy backscatter scheme << '')')
      WRITE(*,'('' Total backscattered energy, TOT_BACKSCAT_T   '',E12.5)') TOT_BACKSCAT
      WRITE(*,'('' Exponent for energy spectra, REXPONENT_T   ='',E12.5)') REXPONENT
      WRITE(*,'('' Minimal wavenumber of tempearature forcing, LMINFORC ='',I10)') LMINFORCT
      WRITE(*,'('' Maximal wavenumber of tempearature forcing, LMAXFORC ='',I10)') LMAXFORCT
      WRITE(*,'('' Minimal wavenumber of tempearature forcing, KMINFORC ='',I10)') KMINFORCT
      WRITE(*,'('' Maximal wavenumber of tempearature forcing, KMAXFORC ='',I10)') KMAXFORCT
      WRITE(*,'('' skebs_vertstruc                             '',I10)') skebs_vertstruc
      WRITE(*,'('' Decorrelation time of noise, ZTAU_T ='',E12.5)') ZTAU
      WRITE(*,'('' Variance of noise, ZSIGMA2_ETA  ='',E12.5)') ZSIGMA2
      WRITE(*,'('' Autoregressive parameter 1-ALPH_T ='',E12.5)') 1.-ALPH
      WRITE(*,'('' =============================================='')')
      endif
    IF((variable == 'P') .or. (variable == 'R') .or.  (variable == 'S') .or. &
       (variable == 'O') .or. (variable == 'Q') .or.  (variable == 'K') .or. &
       (variable == 'K') .or. (variable == 'L') ) then
      kappat= L_rand_perturb**2 ! L^2= kappa*T,  where L is a length scale in m; set to for L=100km 
      phi = exp (-float(itime_step)/tau_rand_perturb)
      alph = 1.-phi
     endif 

!     --------------------------------------------------------------------------------------
!     ---------- INITIALIZE STOCHASTICALLY PERTURBED PHYSICAL TENDENCY SCHEME --------------
!     --------------------------------------------------------------------------------------
     if (variable == 'P') then
      WRITE(*,'(''                                               '')')
      WRITE(*,'('' =============================================='')')
      WRITE(*,'('' >> Initializing Stochastically Perturbed Physics Tendency scheme << '')')
      WRITE(*,'('' sppt_vertstruc                              '',I10)') skebs_vertstruc
      WRITE(*,'('' Time step: itime_step='',I10)') itime_step
      WRITE(*,'('' Decorrelation time of noise, Tau ='',E12.5)') tau_rand_perturb
      WRITE(*,'('' Autoregressive parameter Phi ='',E12.5)') phi
      WRITE(*,'('' Length Scale L'',E12.5)') l_rand_perturb
      WRITE(*,'('' Variance in gridpoint space'',E12.5)') gridpt_stddev_rand_perturb
      WRITE(*,'('' =============================================='')')
      endif ! variable 

!     --------------------------------------------------------------------------------------
!     --------------------  INITIALIZE  RANDOM PERTUBATIONS  -------------------------------
!     --------------------------------------------------------------------------------------
     if (variable == 'R') then
      WRITE(*,'(''                                               '')')
      WRITE(*,'('' =============================================='')')
      WRITE(*,'('' >> Initializing random pertubations << '')')
      WRITE(*,'('' rand_pert_vertstruc                         '',I10)') skebs_vertstruc
      WRITE(*,'('' Time step: itime_step='',I10)') itime_step
      WRITE(*,'('' Decorrelation time of noise, Tau ='',E12.5)') tau_rand_perturb
      WRITE(*,'('' Autoregressive parameter Phi ='',E12.5)') phi
      WRITE(*,'('' Length Scale L'',E12.5)') l_rand_perturb
      WRITE(*,'('' Variance in gridpoint space'',E12.5)') gridpt_stddev_rand_perturb
      WRITE(*,'('' =============================================='')')
      endif ! variable 
     endif !is print

!     --------------------------------------------------------------------------------------
!     --------------------  INITIALIZE  iSPPT  ---------------------------------------------
!     --------------------------------------------------------------------------------------
     if (variable == 'S') then 
      WRITE(*,'(''                                               '')')
      WRITE(*,'('' =============================================='')')
      WRITE(*,'('' >> Initializing iSPPT for Micro-physics<< '')')
      WRITE(*,'('' rand_pert_vertstruc_isppt_mp                    '',I10)') skebs_vertstruc
      WRITE(*,'('' Decorrelation time of noise, Tau ='',E12.5)') tau_rand_perturb
      WRITE(*,'('' Autoregressive parameter Phi ='',E12.5)') phi
      WRITE(*,'('' Length Scale L'',E12.5)') l_rand_perturb
      WRITE(*,'('' Variance in gridpoint space'',E12.5)') gridpt_stddev_rand_perturb
      WRITE(*,'('' Time step: itime_step='',I10)') itime_step !xiaohzhao
      WRITE(*,'('' =============================================='')')
     endif ! variable 

     if (variable == 'Q') then 
      WRITE(*,'(''                                               '')')
      WRITE(*,'('' =============================================='')')
      WRITE(*,'('' >> Initializing iSPPT for PBL<< '')')
      WRITE(*,'('' rand_pert_vertstruc_isppt_pbl                   '',I10)') skebs_vertstruc
      WRITE(*,'('' Decorrelation time of noise, Tau ='',E12.5)') tau_rand_perturb
      WRITE(*,'('' Autoregressive parameter Phi ='',E12.5)') phi
      WRITE(*,'('' Length Scale L'',E12.5)') l_rand_perturb
      WRITE(*,'('' Variance in gridpoint space'',E12.5)') gridpt_stddev_rand_perturb
      WRITE(*,'('' =============================================='')')
     endif ! variable 

     if (variable == 'O') then 
      WRITE(*,'(''                                               '')')
      WRITE(*,'('' =============================================='')')
      WRITE(*,'('' >> Initializing iSPPT for Radiation<< '')')
      WRITE(*,'('' rand_pert_vertstruc_isppt_mp                    '',I10)') skebs_vertstruc
      WRITE(*,'('' Decorrelation time of noise, Tau ='',E12.5)') tau_rand_perturb
      WRITE(*,'('' Autoregressive parameter Phi ='',E12.5)') phi
      WRITE(*,'('' Length Scale L'',E12.5)') l_rand_perturb
      WRITE(*,'('' Variance in gridpoint space'',E12.5)') gridpt_stddev_rand_perturb
      WRITE(*,'('' =============================================='')')
     endif ! variable 
     if (variable == 'K') then 
      WRITE(*,'(''                                               '')')
      WRITE(*,'('' =============================================='')')
      WRITE(*,'('' >> Initializing iSPPT for Convection<< '')')
      WRITE(*,'('' rand_pert_vertstruc_isppt_conv                  '',I10)') skebs_vertstruc
      WRITE(*,'('' Decorrelation time of noise, Tau ='',E12.5)') tau_rand_perturb
      WRITE(*,'('' Autoregressive parameter Phi ='',E12.5)') phi
      WRITE(*,'('' Length Scale L'',E12.5)') l_rand_perturb
      WRITE(*,'('' Variance in gridpoint space'',E12.5)') gridpt_stddev_rand_perturb
      WRITE(*,'('' =============================================='')')
     endif ! variable 

!     --------------------------------------------------------------------------------------
!     --------------------  INITIALIZE  SPP  ---------------------------------------------
!     --------------------------------------------------------------------------------------
     if (variable == 'L') then 
      WRITE(*,'(''                                               '')')
      WRITE(*,'('' =============================================='')')
      WRITE(*,'('' >> Initializing Parameter Perturbations for Micro-physics<< '')')
      WRITE(*,'('' rand_pert_vertstruc_spp_mp                  '',I10)') skebs_vertstruc
      WRITE(*,'('' Decorrelation time of noise, Tau ='',E12.5)') tau_rand_perturb
      WRITE(*,'('' Autoregressive parameter Phi ='',E12.5)') phi
      WRITE(*,'('' Length Scale L'',E12.5)') l_rand_perturb
      WRITE(*,'('' Variance in gridpoint space'',E12.5)') gridpt_stddev_rand_perturb
      WRITE(*,'('' =============================================='')')
     endif ! variable 

!     --------------------------------------------------------------------------------------
!     Compute Normalization constants       
!     --------------------------------------------------------------------------------------

     WRITE(*,'(''                                               '')')
     WRITE(*,'('' jds,jde  '',I10,I10)') jds,jde 
     WRITE(*,'('' ids,ide  '',I10,I10)') ids,ide 
     WRITE(*,'('' KMAXFORCT '',I10)') KMAXFORCT 
     WRITE(*,'('' KMINFORCT '',I10)') KMINFORCT 
     WRITE(*,'('' LMAXFORCT '',I10)') LMAXFORCT 
     WRITE(*,'('' LMINFORCT '',I10)') LMINFORCT 
     ZCHI    =  0.0
     ZGAMMAN  =  0.0
      ! Fill lower left quadrant of ZCHI. For this range the indeces IK,IL
      DO IK=jds-1,jde   ! These are now wavenumbers
      DO IL=ids-1,ide
      if (((sqrt((IK/RY*IK/RY)+(IL/RX*IL/RX)).lt.((KMAXFORCT+0.5)/RX)).and.&
           (sqrt((IK/RY*IK/RY)+(IL/RX*IL/RX)).ge.((KMINFORCT-0.5)/RX))) .or. &
          ((sqrt((IK/RY*IK/RY)+(IL/RX*IL/RX)).lt.((LMAXFORCT+0.5)/RX)).and.&
           (sqrt((IK/RY*IK/RY)+(IL/RX*IL/RX)).ge.((LMINFORCT-0.5)/RX))))then
        if ((IK>0).or.(IL>0)) then
          if (variable == 'W') then
            ZCHI(IL+1,IK+1)=((IK/RY*IK/RY)+(IL/RX*IL/RX))**(REXPONENT/2.)  ! SKEBS :U 
            ZGAMMAN= ZGAMMAN + ((IK/RY*IK/RY)+(IL/RX*IL/RX))**(REXPONENT+1)        
          else if (variable == 'T') then
            ZCHI(IL+1,IK+1)=((IK/RY*IK/RY)+(IL/RX*IL/RX))**(REXPONENT/2.)  ! SKEBS :T
            ZGAMMAN= ZGAMMAN + ((IK/RY*IK/RY)+(IL/RX*IL/RX))**(REXPONENT)          
          elseif ((variable == 'P') .or. (variable == 'R') .or.  (variable == 'S') .or. &
              (variable == 'O') .or. (variable == 'Q') .or.  (variable == 'K') .or. &
              (variable == 'K') .or. (variable == 'L')) then
            ZCHI(IL+1,IK+1)=exp(  -2*RPI**2*kappat*((IK/RY*IK/RY)+(IL/RX*IL/RX)) ) !SPPT
            ZGAMMAN= ZGAMMAN + exp(  -4*RPI**2*kappat*((IK/RY*IK/RY)+(IL/RX*IL/RX)) ) !SPPT
          endif
        endif
      endif
      enddo
      enddo
      ZGAMMAN=4.0*ZGAMMAN !account for all quadrants, although only one is Filled
      if (variable == 'W') then
         ZCONSTF0=SQRT(ALPH*TOT_BACKSCAT/(float(itime_step)*ZSIGMA2*ZGAMMAN))/(2*RPI)
      elseif  (variable == 'T') then     
         ZCONSTF0=SQRT(T0*ALPH*TOT_BACKSCAT/(float(itime_step)*cp*ZSIGMA2*ZGAMMAN))
      elseif ((variable == 'P') .or. (variable == 'R') .or.  (variable == 'S') .or. &
              (variable == 'O') .or. (variable == 'Q') .or.  (variable == 'K') .or. &
              (variable == 'K') .or. (variable == 'L')) then
         ZCONSTF0= gridpt_stddev_rand_perturb*sqrt((1.-phi**2)/(2.*ZGAMMAN))
      endif

!     --------------------------------------------------------------------------------------
!     Now the wavenumber-dependent amplitudes
!     --------------------------------------------------------------------------------------
!     Note: There are symmetries and anti-symmetries to ensure real-valued back transforms
!     Fill lower left quadrant of matrix of noise amplitudes for wavenumbers K=0,KMAX/2
      SP_AMP=0.0
      DO IK=jts,jte
      DO IL=its,ite
      if ((IL .le. (LMAX/2+1)) .and. (IK .le. (KMAX/2+1)) ) then
        SP_AMP(IL,IK)      = ZCONSTF0*ZCHI(IL,IK)
      endif
      ENDDO
      ENDDO

      ! Fill other quadrants:
      ! Upper left quadrant
      DO IK=jts,jte
      DO IL=its,ite
      if ( (IL .gt. (LMAX/2+1)) .and. (IK .le. (KMAX/2+1)) ) then
        SP_AMP(IL,IK)      =  ZCONSTF0*ZCHI(LMAX-IL+2,IK)
      endif
      ENDDO
      ENDDO

!     Lower right quadrant
      DO IK=jts,jte
      DO IL=its,ite
      if ((IK .gt. (KMAX/2+1)) .and. (IL.le.LMAX/2) ) then
        SP_AMP(IL,IK)      = ZCONSTF0*ZCHI(IL,KMAX-IK+2)
      endif
      ENDDO
      ENDDO

!     Upper right quadrant
      DO IK=jts,jte
      DO IL=its,ite
      if ((IK .gt. (KMAX/2+1)) .and. (IL.gt.LMAX/2) ) then
        SP_AMP(IL,IK)      = ZCONSTF0*ZCHI(LMAX-IL+2,KMAX-IK+2)
      endif
      ENDDO
      ENDDO

!     -----------------------------------------
!     Array for vertical structure if desired
      VERTAMP=1.0 ! Define vertical amplitude here.

      IF (skebs_vertstruc==1) then
        VERTSTRUCC=0.0
        VERTSTRUCS=0.0
        RHOKLMAX= sqrt(KMAX**2/DY**2 + LMAX**2/DX**2)
        ZREF=32.0
        DO ILEV=kts,kte
          DO IK=jts,jte
            DO IL=its,ite
            if (IL.le.(LMAX/2)) then
              RHOKL   = sqrt((IK+1)**2/DY**2 + (IL+1)**2/DX**2)
              EPS     = ((RHOKLMAX - RHOKL)/ RHOKLMAX)  * (ILEV/ZREF) * RPI
              VERTSTRUCC(IL,IK,ILEV) =  cos ( eps* (IL+1) ) !xiaohzhao
              VERTSTRUCS(IL,IK,ILEV) =  sin ( eps* (IL+1) ) !xiaohzhao
             else
              RHOKL   = sqrt((IK+1)**2/DY**2 + (LMAX-IL+2)**2/DX**2)
              EPS     = ((RHOKLMAX - RHOKL)/ RHOKLMAX)  * (ILEV/ZREF) * RPI
              VERTSTRUCC (IL,IK,ILEV) =   cos ( eps* (LMAX-IL+2) ) !xiaohzhao
              VERTSTRUCS (IL,IK,ILEV) = - sin ( eps* (LMAX-IL+2) ) !xiaohzhao
            endif
            ENDDO
          ENDDO
        ENDDO
      ENDIF

     END subroutine SETUP_RAND_PERTURB

!     ------------------------------------------------------------------
!************** UPDATE STOCHASTIC PATTERN IN WAVENUMBER SPACE**********
!     ------------------------------------------------------------------

     subroutine UPDATE_STOCH(                                         & 
                      SPFORCS,SPFORCC,SP_AMP,ALPH,                    &
                      restart,iseedarr,                             &
                      ids, ide, jds, jde, kds, kde,                   &
                      ims, ime, jms, jme, kms, kme,                   &
                      its, ite, jts, jte, kts, kte                    )
     IMPLICIT NONE

     REAL, DIMENSION( ids:ide,jds:jde)      :: ZRANDNOSS,ZRANDNOSC
     REAL, DIMENSION (ims:ime,jms:jme)      :: SPFORCS,SPFORCC,SP_AMP
     INTEGER , INTENT(IN)     ::               ids, ide, jds, jde, kds, kde,   &
                                               ims, ime, jms, jme, kms, kme,   &
                                               its, ite, jts, jte, kts, kte
   
     INTEGER, DIMENSION (kms:kme),             INTENT(INOUT) :: iseedarr
     INTEGER , ALLOCATABLE , DIMENSION(:) :: iseed
     REAL :: Z,ALPH
     REAL, PARAMETER :: thresh = 3.0
     INTEGER ::IL, IK,LMAX,KMAX
     INTEGER :: how_many
     LOGICAL :: LGAUSS,RESTART

     KMAX=(jde-jds)+1 !NLAT
     LMAX=(ide-ids)+1 !NATX

           CALL random_seed(size=how_many)
           IF ( ALLOCATED(iseed)) DEALLOCATE(iseed)
           ALLOCATE(iseed(how_many))
           iseed=iseedarr(1:how_many)
           call random_seed(put=iseed(1:how_many))

!     Pick the distribution of the noise
!     Random noise uses global indexes to ensure necessary symmetries and anti-symmetries
!     of random forcing when run on multiple processors
     LGAUSS=.true.
     IF (LGAUSS) then
       DO IK=jds,jde
         DO IL=ids,ide
          do
           call gauss_noise(z)
           if (abs(z)<thresh) exit
          ENDDO
          ZRANDNOSS(IL,IK)=z
          do
           call gauss_noise(z)
           if (abs(z)<thresh) exit
          ENDDO
          ZRANDNOSC(IL,IK)=z
         ENDDO
       ENDDO
     ELSE
       DO IK=jds,jde
         DO IL=ids,ide
           CALL RANDOM_NUMBER(z)
           ZRANDNOSS(IL,IK)=z-0.5
           CALL RANDOM_NUMBER(z)
           ZRANDNOSC(IL,IK)=z-0.5
          ENDDO
        ENDDO
      ENDIF

!     Note: There are symmetries and anti-symmetries to ensure real-valued back transforms
! for symmetric part: left and right half axis symmetric

      DO IK=jts,jte
      if ((IK.le.(KMAX/2+1)) .and. (IK>1)) then ! Upper half
        DO IL=its,ite
          SPFORCC(IL,IK)       = (1.-ALPH)*SPFORCC(IL,IK)      + SP_AMP(IL,IK)     * ZRANDNOSC(IL,IK)  
          SPFORCS(IL,IK)       = (1.-ALPH)*SPFORCS(IL,IK)      + SP_AMP(IL,IK)     * ZRANDNOSS(IL,IK)  
        ENDDO
      ELSEIF (IK==1) then
        DO IL=its,ite
        if ((IL.le.(LMAX/2+1))) then
          SPFORCC(IL,IK)       = (1.-ALPH)*SPFORCC(IL,IK)      + SP_AMP(IL,IK)     * ZRANDNOSC(IL,IK)  
          SPFORCS(IL,IK)       = (1.-ALPH)*SPFORCS(IL,IK)      + SP_AMP(IL,IK)     * ZRANDNOSS(IL,IK)  
        elseif ((IL.gt.(LMAX/2+1))) then
          SPFORCC(IL,IK)       = (1.-ALPH)*SPFORCC(IL,IK)      + SP_AMP(IL,IK)     * ZRANDNOSC(LMAX-IL+2,IK)  
          SPFORCS(IL,IK)       = (1.-ALPH)*SPFORCS(IL,IK)      - SP_AMP(IL,IK)     * ZRANDNOSS(LMAX-IL+2,IK)  
        endif
        ENDDO
      ENDIF
      ENDDO

      DO IK=jts,jte
      if (IK.gt.(KMAX/2+1)) then ! Lower half
        DO IL=its,ite
          if (IL.le.(LMAX/2+1).and.(IL.gt.1)) then !lower left 
           SPFORCC(IL,IK)      = (1.-ALPH)* SPFORCC(IL,IK)      + SP_AMP(IL,IK)      * ZRANDNOSC(LMAX-IL+2,KMAX-IK+2)
           SPFORCS(IL,IK)      = (1.-ALPH)* SPFORCS(IL,IK)      - SP_AMP(IL,IK)      * ZRANDNOSS(LMAX-IL+2,KMAX-IK+2)
          elseif (IL.eq.1) then !don't exceed index
           SPFORCC(IL,IK)      = (1.-ALPH)* SPFORCC(IL,IK)      + SP_AMP(IL,IK)      * ZRANDNOSC(        1,KMAX-IK+2)
           SPFORCS(IL,IK)      = (1.-ALPH)* SPFORCS(IL,IK)      - SP_AMP(IL,IK)      * ZRANDNOSS(        1,KMAX-IK+2)
          elseif (IL.gt.(LMAX/2+1)) then !lower right
           SPFORCC(IL,IK)      = (1.-ALPH)* SPFORCC(IL,IK)      + SP_AMP(IL,IK)      * ZRANDNOSC(LMAX-IL+2,KMAX-IK+2)
           SPFORCS(IL,IK)      = (1.-ALPH)* SPFORCS(IL,IK)      - SP_AMP(IL,IK)      * ZRANDNOSS(LMAX-IL+2,KMAX-IK+2)
          endif
        ENDDO
      endif
      ENDDO

      call random_seed(get=iseed(1:how_many))
      iseedarr=0.0
      iseedarr(1:how_many)=iseed

     END subroutine UPDATE_STOCH
!     ------------------------------------------------------------------
      SUBROUTINE UPDATE_STOCH_TEN(ru_tendf,rv_tendf,t_tendf, &
                       ru_tendf_stoch,rv_tendf_stoch,rt_tendf_stoch,& 
                       mu,mub,                                      & 
                       ids, ide, jds, jde, kds, kde,                &
                       ims, ime, jms, jme, kms, kme,                &
                       its, ite, jts, jte, kts, kte,                &
                       kte_stoch,kme_stoch                          )

       IMPLICIT NONE
       INTEGER , INTENT(IN)        ::  ids, ide, jds, jde, kds, kde,   &
                                       ims, ime, jms, jme, kms, kme,   &
                                       its, ite, jts, jte, kts, kte,   & 
                                       kte_stoch,kme_stoch

       REAL , DIMENSION(ims:ime , kms:kme, jms:jme),INTENT(INOUT) :: &
                                       ru_tendf, rv_tendf, t_tendf

       REAL , DIMENSION(ims:ime , kms:kme_stoch, jms:jme)           :: &
                      ru_tendf_stoch,rv_tendf_stoch,rt_tendf_stoch 

       REAL , DIMENSION(ims:ime,jms:jme) , INTENT(IN) :: mu,mub

       INTEGER :: I,J,K,kh
       REAL  :: dt,xm

   
       DO j = jts,MIN(jde-1,jte)
         DO k = kts,kte-1
           kh=min(k,kte_stoch)
           DO i = its,ite 
             ru_tendf(i,k,j) = ru_tendf(i,k,j) +  ru_tendf_stoch(i,kh,j)  * (mu(i,j)+mub(i,j)) 
           ENDDO
         ENDDO
       ENDDO

       DO j = jts,jte
         DO k = kts,kte-1
           kh=min(k,kte_stoch)
           DO i = its,MIN(ide-1,ite)
             rv_tendf(i,k,j) = rv_tendf(i,k,j) +  rv_tendf_stoch(i,kh,j) *  (mu(i,j)+mub(i,j)) 
           ENDDO
         ENDDO
       ENDDO

       DO j = jts,MIN(jde-1,jte)
         DO k = kts,kte-1
           kh=min(k,kte_stoch)
           DO i = its,MIN(ide-1,ite)
             t_tendf(i,k,j) = t_tendf(i,k,j) + rt_tendf_stoch(i,kh,j) * (mu(i,j)+mub(i,j))
           ENDDO
         ENDDO
       ENDDO

       END SUBROUTINE UPDATE_STOCH_TEN
!     ------------------------------------------------------------------
!!************** PERTURB PHYSICS TENDENCIES (except T) FOR SPPT *******************
!     ------------------------------------------------------------------
      subroutine perturb_physics_tend(gridpt_stddev_sppt,               & 
                       sppt_thresh_fact,rstoch,                         & 
                       ru_tendf,rv_tendf,t_tendf,moist_tend,            &
                       ids, ide, jds, jde, kds, kde,                    &
                       ims, ime, jms, jme, kms, kme,                    &
                       its, ite, jts, jte, kts, kte,                    & 
                       kte_stoch,kme_stoch                               )

!      This subroutine add stochastic perturbations of the form 
!
!                  rx_tendf(i,k,j)      = rx_tendf(i,k,j)*(1.0 + rstoch(i,k,j))
!
!       to the tendencies of  U, V, and Q. 
!       Since the temperature perturbations do not include the micro-physics
!       tendencies at this point, the stochastic tendency perturbations to 
!       temperature are added in subroutine rk_addtend_dry of module module_em.F

       IMPLICIT NONE
       INTEGER , INTENT(IN)        ::  ids, ide, jds, jde, kds, kde,   &
                                       ims, ime, jms, jme, kms, kme,   &
                                       its, ite, jts, jte, kts, kte,   & 
                                       kte_stoch,kme_stoch

       REAL , DIMENSION(ims:ime , kms:kme, jms:jme),INTENT(INOUT) ::   &
                                        ru_tendf, rv_tendf, t_tendf,moist_tend
       REAL , DIMENSION(ims:ime,kms:kme_stoch, jms:jme),INTENT(INOUT) :: rstoch
       REAL :: gridpt_stddev_sppt ,thresh,sppt_thresh_fact

       INTEGER :: I,J,K,kh

! Here the random process at each gridpoint is capped if it exceeds a value thresh 

       thresh=sppt_thresh_fact*gridpt_stddev_sppt
       DO j = jts,jte
         DO k = kts,min(kte-1,kte_stoch-1)
           DO i = its,ite 
!                rstoch(i,k,j)=MAX(MIN(rstoch(i,k,j),thresh),-1.*thresh))
             if (rstoch(i,k,j).lt.-thresh) then
                 rstoch(i,k,j)=-thresh
             endif
             if (rstoch(i,k,j).gt.thresh) then
                 rstoch(i,k,j)=thresh
             endif
           ENDDO
         ENDDO
       ENDDO

! Perturb the tendencies of u,v,q,t.
       DO j = jts,MIN(jde-1,jte)
         DO k = kts,kte-1
         kh = min( k, kte_stoch-1 ) 
           DO i = its,ite 
              ru_tendf(i,k,j)      = ru_tendf(i,k,j)*(1.0 + rstoch(i,kh,j))
           ENDDO
         ENDDO
       ENDDO

       DO j = jts,jte
         DO k = kts,kte-1
         kh = min( k, kte_stoch-1 ) 
            DO i = its,MIN(ide-1,ite)
              rv_tendf(i,k,j)      = rv_tendf(i,k,j)*(1.0 + rstoch(i,kh,j))
           ENDDO
         ENDDO
       ENDDO

       DO j = jts,MIN(jde-1,jte)
         DO k = kts,kte-1
         kh = min( k, kte_stoch-1 ) 
           DO i = its,MIN(ide-1,ite)
              moist_tend(i,k,j)    = moist_tend(i,k,j)*(1.0 + rstoch(i,kh,j))
              t_tendf   (i,k,j)    =    t_tendf(i,k,j)*(1.0 + rstoch(i,kh,j))
           ENDDO
         ENDDO
       ENDDO

      end subroutine perturb_physics_tend

!     ------------------------------------------------------------------
!!************** PERTURB MP-PHYSICS TENDENCIES with iSPPT **************
!--------------------------------------------------------------------

!<DESCRIPTION>
!
!  perturb_mp_tend uses the micro-physics tendencies qv_diabatic and 
!  h_diabatic to compute SPPT perturbations. These are then added
!  as increments to the already updated state t_new (theta after 
!  call to micro-physics) and qv. The micro-physics tendencies 
!  qv_diabatic and h_diabatic are updated as well, since they are 
!  used in the next timestep, and should reflect the perturbed tendency.
!
!</DESCRIPTION>

!--------------------------------------------------------------------
SUBROUTINE perturb_mp_tend(isppt_mp,pattern_isppt_mp,                     &  
                           stddev_cutoff_isppt_mp,gridpt_stddev_isppt_mp, & 
                           t_new,                     &    
                           train_ins, nphs, dt,       &    
                           qv, qv_ins,                &    
                           config_flags,              &    
                           ids,ide, jds,jde, kds,kde, &
                           ims,ime, jms,jme, kms,kme, &
                           its,ite, jts,jte, kts,kte, &
                           kte_stoch,kme_stoch        )


   USE module_configure
   IMPLICIT NONE 

    TYPE(grid_config_rec_type),    INTENT(IN   )    :: config_flags
!   TYPE ( domain ), INTENT(INOUT)         :: grid

   INTEGER,      INTENT(IN   )    :: ids,ide, jds,jde, kds,kde
   INTEGER,      INTENT(IN   )    :: ims,ime, jms,jme, kms,kme
   INTEGER,      INTENT(IN   )    :: its,ite, jts,jte, kts,kte
   INTEGER,      INTENT(IN   )    :: kte_stoch,kme_stoch
   INTEGER,      INTENT(IN   )    :: nphs

   REAL, DIMENSION( ims:ime , jms:jme, kms:kme ),        &    
         INTENT(INOUT) ::            t_new,qv,train_ins,qv_ins     !xiaohzhao
   REAL, DIMENSION( ims:ime ,  jms:jme, kms:kme_stoch),        &                                                   
         INTENT(INOUT) ::                      pattern_isppt_mp !xiaohzhao

   REAL :: thresh, mpten, mptenmax, mptenmin, th_mp_inc
   REAL :: dtphs !xiaohzhao
   REAL, INTENT(IN   ) :: dt,gridpt_stddev_isppt_mp,stddev_cutoff_isppt_mp
   INTEGER, INTENT(IN) :: isppt_mp

   INTEGER :: i_start, i_end, j_start, j_end, iendx
   INTEGER :: i, j, k, kh, imax, jmax, imin, jmin
   LOGICAL :: E_BDY
    
!--------------------------------------------------------------------
!  set up loop bounds for this grid's boundary conditions
   i_start = MAX(ids+1,its)
   i_end   = MIN(ide-1,ite)
   j_start = MAX(jds+2,jts)
   j_end   = MIN(jde-2,jte)
   ! Here the random process at each gridpoint is capped if it exceeds a value thresh
   ! KL: capping code copied/adapted from phys/module_physics_addtendc.F
     thresh=stddev_cutoff_isppt_mp*gridpt_stddev_isppt_mp
!$omp parallel do &
!$omp& private(i,j,k)
    DO j = jts,jte!j_start,j_end 
    DO k = kts,MIN(kte-1,kte_stoch-1)
    DO i = its,ite!i_start,i_end 
     pattern_isppt_mp(i,j,k)=MAX(MIN(pattern_isppt_mp(i,j,k),thresh),-1.*thresh)
    ENDDO
    ENDDO
    ENDDO

    dtphs=nphs*dt
    mptenmax = 0.
    mptenmin = 999.
!    train_ins(i,k,j) =  mpten/dt is mp theta-tendency
!    qv_ins(i,k,j) =  qvten/dt is mp qv-tendency
    E_BDY=(ite>=ide)
!$omp parallel do &
!$omp& private(i,j,k,kh,iendx,mpten,th_mp_inc)
    DO j = j_start, j_end
    DO k = kts,kte-1
      kh = MIN( k, kte_stoch-1 )
      iendx = i_end
      IF(E_BDY.AND.MOD(j,2)==0)iendx=iendx-1
    DO i = i_start,iendx 
      mpten = train_ins(i,j,k)*dtphs
      qv(i,j,k) = qv(i,j,k)+qv_ins(i,j,k)*pattern_isppt_mp(i,j,kh)*dtphs
      t_new(i,j,k) = t_new(i,j,k)+mpten*pattern_isppt_mp(i,j,kh)
      train_ins(i,j,k) = (1.0+pattern_isppt_mp(i,j,kh))*train_ins(i,j,k)
      qv_ins(i,j,k) = (1.0+pattern_isppt_mp(i,j,kh))*qv_ins(i,j,k)
      th_mp_inc = (1.0+pattern_isppt_mp(i,j,kh))*mpten ! total theta incremement including perturbation
!    JB: Check that water vapor does not become negative. If it does, add qv-sink to adjacent grid-box, 
!    so that water vapor is conserved.
      if (qv(i,j,k)<0.0) then 
        if (i<iendx) then
             qv(i+1,j,k) = qv(i+1,j,k) + qv(i,j,k)
        else
             qv(i-1,j,k) = qv(i-1,j,k) + qv(i,j,k)
!!              if (qv_ins(i-1,k,j) < 0 ) then 
!!               print*,'JB: The qv-fixer in SPPT didnt work properly. We have sources of water now.'
!!               stop
!!              endif
       endif
       qv(i,j,k) =0.0
     endif

! JB:  Limiter from module_big_step_utilities_em.F used to limit 
! Theta incremement due to MP. Need to be tested to see if/how this
! limiter affects stochastic perturbations. Acts on increment, not tendency.
! This limiter might not be necessary. It has been introduced so that Air Force
! can run Thompson micro-physics with a larger timestep than designed. Tends
! to switch on in regions of strong tropical convection
       if(th_mp_inc .gt.mptenmax) then ! The th-increment is limited. 
           mptenmax=th_mp_inc
           imax=i
           jmax=j
        endif
        if(th_mp_inc.lt.mptenmin) then
           mptenmin=th_mp_inc
           imin=i
           jmin=j
        endif
!        th_mp_inc=min(config_flags%mp_tend_lim*dt, mpten)
!        th_mp_inc=max(-config_flags%mp_tend_lim*dt, mpten)
     ENDDO
     ENDDO
     ENDDO

   END SUBROUTINE perturb_mp_tend
!     ------------------------------------------------------------------
!!************** UPDATE SPECTRAL PATTERN AND TRANFORM GRIDPOINT SPACE***
!     ------------------------------------------------------------------
! This subroutine evolves the spectral pattern and transforms it back to gridpoint space.


      SUBROUTINE RAND_PERT_UPDATE       (grid, variable_in,                   &
                          SPFORCS,SPFORCC,SP_AMP,ALPH_RAND,                   &
                          ips, ipe, jps, jpe, kps, kpe,                       &
                          ids, ide, jds, jde, kds, kde,                       &
                          ims, ime, jms, jme, kms, kme,                       &
                          kts, kte,                                           &
                          imsx,imex,jmsx,jmex,kmsx,kmex,                      &
                          ipsx,ipex,jpsx,jpex,kpsx,kpex,                      &
                          imsy,imey,jmsy,jmey,kmsy,kmey,                      &
                          ipsy,ipey,jpsy,jpey,kpsy,kpey,                      &
                          kpe_stoch,kde_stoch,kme_stoch,kte_stoch,            &
                          restart,iseedarr,                                   &
                          DX,DY,skebs_vertstruc,                          &
                          RAND_PERT,                                          &
                          VERTSTRUCC,VERTSTRUCS,VERTAMP                       )



    USE module_domain, ONLY : domain
#ifdef DM_PARALLEL
    USE module_dm, ONLY : local_communicator, mytask, ntasks, ntasks_x, ntasks_y, local_communicator_periodic, &
                          wrf_dm_maxval, wrf_err_message, local_communicator_x, local_communicator_y, data_order_xyz!xiaohzhao !data_order_xzy
#endif


      IMPLICIT NONE

      TYPE ( domain ), INTENT(INOUT) :: grid

 
      INTEGER , INTENT(IN)     ::               ids, ide, jds, jde, kds, kde,   &
                                                ims, ime, jms, jme, kms, kme,   &
                                                ips, ipe, jps, jpe, kps, kpe,   & 
                                                kts, kte                       
      INTEGER , INTENT(IN)     ::               imsx,imex,jmsx,jmex,kmsx,kmex, &
                                                ipsx,ipex,jpsx,jpex,kpsx,kpex, &
                                                imsy,imey,jmsy,jmey,kmsy,kmey, &
                                                ipsy,ipey,jpsy,jpey,kpsy,kpey
      INTEGER                  ::               kpe_stoch,kde_stoch,kme_stoch,kte_stoch 

      REAL    , INTENT(IN)     ::               ALPH_RAND,dx,dy
      INTEGER , INTENT(IN)     ::               skebs_vertstruc
      CHARACTER, INTENT(IN)    ::               variable_in ! T, U, V                
                                               ! T          ! random field, T
                                               ! U          ! first derivative of streamfunction with regard to y; for skebs: U
                                               ! V          ! first derivative of streamfunction with regard to x; for skebs: V

      INTEGER, DIMENSION (kms:kme),             INTENT(INOUT) :: iseedarr
      REAL, DIMENSION(ims:ime,jms:jme,kms:kme),INTENT(IN)    :: VERTSTRUCC,VERTSTRUCS !xiaohzhao
      REAL, DIMENSION(ims:ime,jms:jme)         ,INTENT(INOUT) :: SPFORCS,SPFORCC,SP_AMP
      REAL, DIMENSION(kms:kme )                ,INTENT(IN)    :: VERTAMP
      REAL, DIMENSION(ims:ime,jms:jme,kms:kme_stoch)         :: RAND_PERT !xiaohzhao 
      REAL                     ::               RY,RX


! Local Variabels 
      INTEGER                 ::               IK,IL,ILEV,NLON,NLAT,IJ,I,J,K
      INTEGER                 ::               gridsp33y,gridsm33y,gridsp33x,gridsm33x,gridsp33 ,gridsm33 !xiaohzhao
      INTEGER                 ::               gridep33y,gridem33y,gridep33x,gridem33x,gridep33 ,gridem33 !xiaohzhao

      !REAL, DIMENSION(ims:ime,kms:kme_stoch,jms:jme)     :: RAND_REAL, RAND_IMAG
      REAL, DIMENSION(ims:ime,jms:jme,kms:kme_stoch)      :: RAND_REAL, RAND_IMAG !xiaohzhao
      LOGICAL :: RESTART
      CHARACTER  :: variable
      variable = variable_in

      NLAT=(jde-jds)+1 !KMAX
      NLON=(ide-ids)+1 !LMAX
      RY=  NLAT*DY
      RX=  NLON*DX

! Update the pattern generator by evolving each spectral coefficients as AR1

      !$OMP PARALLEL DO   &
      !$OMP PRIVATE ( ij )
       DO ij = 1 , grid%num_tiles
             IF (variable .ne. 'V') THEN  !T, random field, U, don't update for V 
              CALL UPDATE_STOCH( &
                         SPFORCS,SPFORCC,SP_AMP,ALPH_RAND,                   &
                         restart,iseedarr,                         &
                         ids, ide, jds, jde, kds, kde,                       &
                         ims, ime, jms, jme, kms, kme,                       &
                         grid%i_start(ij), grid%i_end(ij), grid%j_start(ij), grid%j_end(ij), kts, kte                        )      
             endif
  
! Put spectral coefficients in arrays RAND_REAL,RAND_IMAG 

              IF (variable == 'T')   THEN  ! T, rand 
              DO IK=grid%j_start(ij), grid%j_end(ij)
               DO ILEV=kts,kte_stoch
                DO IL=grid%i_start(ij),grid%i_end(ij)
                       grid%RAND_REAL(IL,IK,ILEV)  = SPFORCC(IL,IK) !xiaohzhao
                       grid%RAND_IMAG(IL,IK,ILEV)  = SPFORCS(IL,IK) !xiaohzhao
                  ENDDO
                ENDDO
              ENDDO

              ELSEIF (variable == 'U') THEN !U  
              DO IK=grid%j_start(ij), grid%j_end(ij)
               DO ILEV=kts,kte_stoch
                DO IL=grid%i_start(ij),grid%i_end(ij)
                       grid%RAND_REAL(IL,IK,ILEV)  =  2*RPI/RY*  wavenumber_k(IK) * SPFORCS(IL,IK)!xiaohzhao
                       grid%RAND_IMAG(IL,IK,ILEV)  = -2*RPI/RY*  wavenumber_k(IK) * SPFORCC(IL,IK)!xiaohzhao
                  ENDDO
                ENDDO
              ENDDO

              ELSEIF (variable == 'V') THEN !V  
              DO IK=grid%j_start(ij), grid%j_end(ij)
               DO ILEV=kts,kte_stoch
                DO IL=grid%i_start(ij),grid%i_end(ij)
                       grid%RAND_REAL(IL,IK,ILEV)  = -2*RPI/RX*  wavenumber_l(IL) * SPFORCS(IL,IK)!xiaohzhao
                       grid%RAND_IMAG(IL,IK,ILEV)  =  2*RPI/RX*  wavenumber_l(IL) * SPFORCC(IL,IK)!xiaohzhao
                  ENDDO
                ENDDO
              ENDDO
              endif


! Apply vertical structure function

           IF (skebs_vertstruc.ne.0) then
             DO ILEV=kts,kte_stoch
              DO IL=grid%i_start(ij),grid%i_end(ij)
                DO IK=grid%j_start(ij), grid%j_end(ij)
                  grid%RAND_REAL(IL,IK,ILEV)  = VERTAMP(ILEV) * & 
                       (grid%RAND_REAL(IL,IK,ILEV) * VERTSTRUCC(IL,IK,ILEV) - grid%RAND_IMAG(IL,IK,ILEV) * VERTSTRUCS(IL,IK,ILEV)) !xiaohzhao
                  grid%RAND_IMAG(IL,IK,ILEV)  = VERTAMP(ILEV) * & 
                       (grid%RAND_REAL(IL,IK,ILEV) * VERTSTRUCS(IL,IK,ILEV) + grid%RAND_IMAG(IL,IK,ILEV) * VERTSTRUCC(IL,IK,ILEV)) !xiaohzhao
                ENDDO
             ENDDO
           ENDDO
           ENDIF
        ENDDO
       !$OMP END PARALLEL DO

! Transform spectral pattern to gridpoint space 
          
#if ( defined( DM_PARALLEL ) && ( ! defined( STUBMPI ) ) )

! Roll out into latitude bands and perform FFT along latitude bands

! Save a copy of the indices as we might need them to change when
! doing the "thin" 3d arrays (where the "k" dimension is unity).
! These are the original Z-transposed and X-transposed k-dimensions.

        gridsp33x=grid%sp33x
        gridep33x=grid%ep33x
        gridsm33x=grid%sm33x
        gridem33x=grid%em33x
        gridsp33 =grid%sp33
        gridep33 =grid%ep33
        gridsm33 =grid%sm33
        gridem33 =grid%em33
! Set number of vertical levels to which ever is smaller: the full number
! of vertical levels, or the number of levels to be transformed into 
! gridpoint space.

        grid%sp33x=min(kpsx,grid%num_stoch_levels)
        grid%ep33x=min(kpex,grid%num_stoch_levels)
        grid%sm33x=min(kmsx,grid%num_stoch_levels)
        grid%em33x=min(kmex,grid%num_stoch_levels)
        grid%sp33 =min(kps ,grid%num_stoch_levels)
        grid%ep33 =min(kpe ,grid%num_stoch_levels)
        grid%sm33 =min(kms ,grid%num_stoch_levels)
        grid%em33 =min(kme ,grid%num_stoch_levels)

         
#include "XPOSE_RAND_REAL_z2x.inc"
#include "XPOSE_RAND_IMAG_z2x.inc"


        call do_fftback_along_x(grid%RAND_REAL_xxx,grid%RAND_IMAG_xxx,                  &
                              ids,ide,jds,jde,                                          & 
                              imsx,imex,jmsx,jmex,kmsx,min(kmex,grid%num_stoch_levels), & 
                              ipsx,ipex,jpsx,jpex,kpsx,min(kpex,grid%num_stoch_levels))  

#include "XPOSE_RAND_REAL_x2z.inc"
#include "XPOSE_RAND_IMAG_x2z.inc"

! Roll out into longitude bands and perform FFT along longitude bands

! Save a copy of the indices as we might need them to change when
! doing the "thin" 3d arrays (where the "k" dimension is unity).
! These are the original Y-transposed k-dimensions.

        gridsp33y=grid%sp33y
        gridsm33y=grid%sm33y
        gridep33y=grid%ep33y
        gridem33y=grid%em33y
   

! Again, set number of vertical levels to the min of the number of levels and the
! number of stochastic levels.

        grid%sp33y=min(kpsy,grid%num_stoch_levels)
        grid%ep33y=min(kpey,grid%num_stoch_levels)
        grid%sm33y=min(kmsy,grid%num_stoch_levels)
        grid%em33y=min(kmey,grid%num_stoch_levels)
         

#include "XPOSE_RAND_REAL_z2y.inc"
#include "XPOSE_RAND_IMAG_z2y.inc"
        call do_fftback_along_y(grid%RAND_REAL_yyy,grid%RAND_IMAG_yyy,                  &
                              ids,ide,jds,jde,                                          & 
                              imsy,imey,jmsy,jmey,kmsy,min(kmey,grid%num_stoch_levels), & 
                              ipsy,ipey,jpsy,jpey,kpsy,min(kpey,grid%num_stoch_levels))
#include "XPOSE_RAND_REAL_y2z.inc"
#include "XPOSE_RAND_IMAG_y2z.inc"

! Put the original vertical "k" dimensions back.

        grid%sp33x=gridsp33x
        grid%sm33x=gridsm33x
        grid%ep33x=gridep33x
        grid%em33x=gridem33x
        grid%sp33y=gridsp33y
        grid%sm33y=gridsm33y
        grid%ep33y=gridep33y
        grid%em33y=gridem33y
        grid%sp33 =gridsp33
        grid%sm33 =gridsm33
        grid%ep33 =gridep33
        grid%em33 =gridem33


#else
        call do_fftback_along_x(grid%RAND_REAL,grid%RAND_IMAG,                          &
                              ids,ide,jds,jde,                                          & 
                              ims,ime,jms,jme,kms,min(kme,grid%num_stoch_levels),       & 
                              ips,ipe,jps,jpe,kps,min(kpe,grid%num_stoch_levels))   
        call do_fftback_along_y(grid%RAND_REAL,grid%RAND_IMAG,                          & 
                              ids,ide,jds,jde,                                          & 
                              ims,ime,jms,jme,kms,min(kme,grid%num_stoch_levels),       & 
                              ips,ipe,jps,jpe,kps,min(kpe,grid%num_stoch_levels))
#endif


      !$OMP PARALLEL DO   &
      !$OMP PRIVATE ( ij )
        DO ij = 1 , grid%num_tiles
               DO k=kts,min(kte,grid%num_stoch_levels)
                 DO I=grid%i_start(ij), grid%i_end(ij)
                   DO j=grid%j_start(ij), grid%j_end(ij)
                     RAND_PERT(I,J,K)=grid%RAND_REAL(I,J,K) 
                   ENDDO
                 ENDDO
                ENDDO
        ENDDO

       !$OMP END PARALLEL DO

       END SUBROUTINE RAND_PERT_UPDATE

!     ------------------------------------------------------------------
!!************** SUBROUTINE DO_FFTBACK_ALONG_X
!     ------------------------------------------------------------------
       subroutine do_fftback_along_x(                            & 
                               fieldc,fields,                    &
                               ids,ide,jds,jde,                  & 
                               imsx,imex,jmsx,jmex,kmsx,kmex,    &
                               ipsx,ipex,jpsx,jpex,kpsx,kpex     ) 
       IMPLICIT NONE
 
       INTEGER, INTENT(IN):: imsx,imex,jmsx,jmex,kmsx,kmex,    &
                             ipsx,ipex,jpsx,jpex,kpsx,kpex,    & 
                             ids,ide,jds,jde

  
       REAL, DIMENSION    (imsx:imex, jmsx:jmex, kmsx:kmex) :: fieldc,fields !xiaohzhao

       COMPLEX, DIMENSION (ipsx:ipex)            :: dummy_complex
       INTEGER                                   :: IER,LENWRK,KMAX,LMAX,I,J,K
       REAL, ALLOCATABLE                         :: WORK(:)

       CHARACTER (LEN=160) :: mess


       KMAX=(jde-jds)+1
       LMAX=(ide-ids)+1
       LENWRK=2*KMAX*LMAX
       ALLOCATE(WORK(LENWRK))
       LENSAV= 4*(KMAX+LMAX)+INT(LOG(REAL(KMAX))) + INT(LOG(REAL(LMAX))) + 8

       DO k=kpsx,kpex 
         DO j = jpsx, jpex
           DO i = ipsx, ipex
             dummy_complex(i)=cmplx(fieldc(i,j,k),fields(i,j,k)) !xiaohzhao
           ENDDO
           CALL cFFT1B (LMAX, 1 ,dummy_complex,LMAX, WSAVE1, LENSAV, WORK, LENWRK, IER)
           if (ier.ne.0) then 
              WRITE(mess,FMT='(A)') 'error in cFFT1B in do_fftback_along_x, field U'
              CALL wrf_debug(0,mess)
           end if
           DO i = ipsx, ipex
             fieldc(i,j,k)=real(dummy_complex(i)) !xiaohzhao
             fields(i,j,k)=imag(dummy_complex(i)) !xiaohzhao
           END DO
         END DO
       END DO

       DEALLOCATE(WORK)
       end subroutine do_fftback_along_x

!!     ------------------------------------------------------------------
!!!************** SUBROUTINE DO_FFTBACK_ALONG_Y
!!     ------------------------------------------------------------------
       subroutine do_fftback_along_y(                            &
                               fieldc,fields,                    &
                               ids,ide,jds,jde,                  & 
                               imsy,imey,jmsy,jmey,kmsy,kmey,    &
                               ipsy,ipey,jpsy,jpey,kpsy,kpey     )
       IMPLICIT NONE
 
       INTEGER :: IER,LENWRK,KMAX,LMAX,I,J,K,skebs_vertstruc
 
       INTEGER, INTENT(IN) :: imsy,imey,jmsy,jmey,kmsy,kmey,    &
                              ipsy,ipey,jpsy,jpey,kpsy,kpey,    & 
                              ids,ide,jds,jde
  
       REAL, DIMENSION    (imsy:imey, jmsy:jmey, kmsy:kmey) :: fieldc,fields !xiaohzhao

       COMPLEX, DIMENSION (jpsy:jpey)            :: dummy_complex
       REAL, ALLOCATABLE :: WORK(:)

       CHARACTER (LEN=160) :: mess

       KMAX=(jde-jds)+1
       LMAX=(ide-ids)+1
       LENWRK=2*KMAX*LMAX
       ALLOCATE(WORK(LENWRK))
       LENSAV= 4*(KMAX+LMAX)+INT(LOG(REAL(KMAX))) + INT(LOG(REAL(LMAX))) + 8



        DO k=kpsy,kpey
          DO i = ipsy, ipey
            DO j = jpsy,jpey
            dummy_complex(j)=cmplx(fieldc(i,j,k),fields(i,j,k)) !xiaohzhao
            ENDDO
            CALL cFFT1B (KMAX, 1 ,dummy_complex,KMAX, WSAVE2, LENSAV, WORK, LENWRK, IER)
            if (ier.ne.0) then 
               WRITE(mess,FMT='(A)') 'error in cFFT1B in do_fftback_along_y, field U'
               CALL wrf_debug(0,mess)
            end if
            DO j = jpsy, jpey
            fieldc(i,j,k)=real(dummy_complex(j))!xiaohzhao
            fields(i,j,k)=imag(dummy_complex(j))!xiaohzhao
            END DO
          END DO
        END DO ! k_start-k_end

     
       DEALLOCATE(WORK)
       end subroutine do_fftback_along_y
!     ------------------------------------------------------------------
!!************** TRANSFORM FROM GRIDPOILT SPACE TO SPHERICAL HARMONICS **
!     ------------------------------------------------------------------
      subroutine findindex( wavenumber_k, wavenumber_L,             & 
                       ids, ide, jds, jde, kds, kde,                &
                       ims, ime, jms, jme, kms, kme,                &
                       its, ite, jts, jte, kts, kte                 )

      IMPLICIT NONE
      INTEGER :: IK,IL,KMAX,LMAX
      INTEGER, DIMENSION (jds:jde)::  wavenumber_k
      INTEGER, DIMENSION (ids:ide)::  wavenumber_l
      INTEGER , INTENT(IN)     ::  ids, ide, jds, jde, kds, kde,   &
                                   ims, ime, jms, jme, kms, kme,   &
                                   its, ite, jts, jte, kts, kte
      KMAX=(jde-jds)+1 
      LMAX=(ide-ids)+1 

      !map wave numbers K,L to indeces IK, IL
      DO IK=1,KMAX/2+1 
        wavenumber_k(IK)=IK-1 
      ENDDO
      DO IK=KMAX,KMAX/2+2,-1
        wavenumber_k(IK)=IK-KMAX-1 
      ENDDO
      DO IL=1,LMAX/2+1 
        wavenumber_l(IL)=IL-1
      ENDDO
      DO IL=LMAX,LMAX/2+2,-1
        wavenumber_l(IL)=IL-LMAX-1 
      ENDDO

      END subroutine findindex
       
!     ------------------------------------------------------------------
     subroutine gauss_noise(z)
      real :: z                    ! output
      real :: x,y,r, coeff         ! INPUT

!  [2.1] Get two uniform variate random numbers IL range 0 to 1:

      do

      call random_number( x )
      call random_number( y )

!     [2.2] Transform to range -1 to 1 and calculate sum of squares:

      x = 2.0 * x - 1.0
      y = 2.0 * y - 1.0
      r = x * x + y * y

      if ( r > 0.0 .and. r < 1.0 ) exit

      end do
!
!  [2.3] Use Box-Muller transformation to get normal deviates:

      coeff = sqrt( -2.0 * log(r) / r )
      z = coeff * x

     end subroutine gauss_noise
!     ------------------------------------------------------------------
     SUBROUTINE rand_seed (config_flags, iseed1, iseedarr, kms, kme)
     USE module_configure
     IMPLICIT NONE
!
!  Structure that contains run-time configuration (namelist) data for domain
      TYPE (grid_config_rec_type)                       :: config_flags
!
! Arguments
     INTEGER             :: kms, kme, iseed1 
     INTEGER, DIMENSION (kms:kme), INTENT(OUT)           :: iseedarr

! Local
      integer*8          :: fctime, one_big
      integer            :: i 

      fctime = config_flags%start_year * ( config_flags%start_month*100+config_flags%start_day) + config_flags%start_hour

      one_big = 1
      iseed1=iseed1+config_flags%nens
      iseedarr=0.0
      do i = kms,kme-3,4
         iseedarr(i  )= iseed1+config_flags%nens*1000000
         iseedarr(i+1)= mod(fctime+iseed1*1000000,19211*one_big)
         iseedarr(i+2)= mod(fctime+iseed1*1000000,71209*one_big)
         iseedarr(i+3)= mod(fctime+iseed1*1000000,11279*one_big)
      enddo

      end SUBROUTINE rand_seed
!     ------------------------------------------------------------------
      end module module_stoch
